C51 COMPILER V9.00   MAIN                                                                  09/21/2024 08:08:56 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c BROWSE INCDIR(..\project_0920) DEBUG OBJECTEXTEND

line level    source

   1          #include <REG52.H>
   2          #include <stdio.h>
   3          #include  "DS1302.h"
   4          #include "LCD1602.h"
   5          #include "Delay.h"
   6          #include "HC_SR04.h"
   7          #include "DS18B20.h"
   8          #include "IR.h"
   9          #include "UART.h"
  10          #include "string.h"
  11          
  12          unsigned int distance;
  13          sbit Buzzer = P2^5;
  14          
  15          unsigned char ThrNum = 10;
  16          unsigned char Address;
  17          unsigned char Command;
  18          unsigned char Command_old;
  19          unsigned int Loop_count = 0;
  20          unsigned char Data[16];
  21          void AT_Init(void);
  22          
  23          float T;
  24          
  25          char putchar(char dat);
  26          void menu(unsigned char, float);
  27          void Delay_ms(unsigned int);
  28          void LCD_ShowInt(unsigned char, unsigned char, int);
  29          void Buzzer_Time(unsigned int ms);   
  30          
  31          void main()
  32          {
  33   1              UART_Init();
  34   1              LCD_Init();
  35   1              LCD_ShowString(1, 1, "AT_Init"); // 第一行显示 "Time:"
  36   1              Delay(500);
  37   1              AT_Init();
  38   1              P3 |= 0xFC;     
  39   1              
  40   1              IR_Init();
  41   1              HC_SR04_Init();
  42   1              DS1302_Init();
  43   1              DS1302_SetTime();
  44   1              while(1)
  45   1              {
  46   2                      Loop_count++;
  47   2                      distance = HC_SR04_GetDistance(); // 获取超声波测得的距离
  48   2                      DS18B20_ConvertT();     //转换温度
  49   2                      T=DS18B20_ReadT();      //读取温度
  50   2                      //printf("%d\r\n", Loop_count);
  51   2                      if (Loop_count > 20){
  52   3                              //UART_Init();
  53   3                              Loop_count = 0;
  54   3                              printf("AT+MQTTPUB=0,\"/sys/k1ryxzSF8vb/0c4qP0fwXkAUsGu2Mfhd/thing/event/property/post\",\"{\\\"params\
             -\\":{\\\"DetectDistance\\\":%d}}\",1,0", distance);
C51 COMPILER V9.00   MAIN                                                                  09/21/2024 08:08:56 PAGE 2   

  55   3                              printf("\r\n");
  56   3                      }
  57   2                  if(IR_GetDataFlag() || IR_GetRepeatFlag()) // 如果收到数据帧或者收到连发帧
  58   2                  {
  59   3                      Address = IR_GetAddress();    // 获取遥控器地址码
  60   3                      Command = IR_GetCommand();    // 获取遥控器命令码
  61   3              
  62   3                      Delay(80);  // 加一个短暂的延时用于去抖动，防止机械抖动影响
  63   3              
  64   3                      // 再次检查按键状态，确保按键没有在去抖时间内改变
  65   3                      if(Command == IR_GetCommand()) {
  66   4                          if(Command == 0x52)       // 如果遥控器VOL-按键按下
  67   4                          {
  68   5                              ThrNum--;             // Num自减
  69   5                              Command = Command_old;
  70   5                          }
  71   4                          if(Command == 0x18)       // 如果遥控器VOL+按键按下
  72   4                          {
  73   5                              ThrNum++;             // Num自增
  74   5                              Command = Command_old;                        
  75   5                          }
  76   4                          LCD_WriteCommand(0x01);    // 光标复位，清屏
  77   4              
  78   4                          switch(Command){
  79   5                              case 0x45:
  80   5                                  DS1302_Init();
  81   5                                  break;
  82   5                              case 0x47:
  83   5                                                      P3 |= 0xFC;
  84   5                                  DS18B20_ConvertT(); // 上电先转换一次温度，防止第一次读数据错误
  85   5                                  Delay(100);          
  86   5                                  break;
  87   5                          }
  88   4              
  89   4                          Command_old = Command;     // 记录上次按键
  90   4                      }
  91   3                  }
  92   2                  menu(Command, T);
  93   2              }
  94   1      }  
  95          
  96          void menu(unsigned char menu_option, float T) {
  97   1          switch (menu_option) {
  98   2              case 0x45:
  99   2                  // 菜单1: 直接在LCD1602上显示时间
 100   2                  DS1302_ReadTime(); // 从DS1302读取时间
 101   2                  // 显示时间在LCD1602 YY/MM/DD HH:MM:SS
 102   2                  LCD_ShowString(1, 1, "Time:"); // 第一行显示 "Time:"
 103   2                  LCD_ShowNum(1, 7, DS1302_Time[0], 2); // 年
 104   2                  LCD_ShowChar(1, 9, '/');
 105   2                  LCD_ShowNum(1, 10, DS1302_Time[1], 2); // 月
 106   2                  LCD_ShowChar(1, 12, '/');
 107   2                  LCD_ShowNum(1, 13, DS1302_Time[2], 2); // 日
 108   2      
 109   2                  LCD_ShowNum(2, 1, DS1302_Time[3], 2); // 小时
 110   2                  LCD_ShowChar(2, 3, ':');
 111   2                  LCD_ShowNum(2, 4, DS1302_Time[4], 2); // 分
 112   2                  LCD_ShowChar(2, 6, ':');
 113   2                  LCD_ShowNum(2, 7, DS1302_Time[5], 2); // 秒
 114   2                  break;
 115   2                                                                                                                 
 116   2              case 0x46:
C51 COMPILER V9.00   MAIN                                                                  09/21/2024 08:08:56 PAGE 3   

 117   2                  // 菜单2: 显示超声波传感器的距离
 118   2              
 119   2                  // 检查是否距离在有效范围内
 120   2                  if (distance != 0xFFFF) {
 121   3                      // 显示超声波测得的距离，单位为cm
 122   3                      LCD_ShowString(1, 1, "Distance:"); 
 123   3                      LCD_ShowNum(1, 10, distance, 3);    
 124   3                      LCD_ShowString(1, 13, "cm");        
 125   3              
 126   3                      // 显示阈值ThrNum在第二行
 127   3                      LCD_ShowString(2, 1, "Threshold:");
 128   3                      LCD_ShowNum(2, 11, ThrNum, 3);
 129   3                      LCD_ShowString(2, 14, "cm");
 130   3              
 131   3                      // 如果距离小于阈值，执行特定的处理逻辑
 132   3                      if (distance < ThrNum) {
 133   4                                      LCD_ShowString(1, 16, "!");
 134   4                      } else {
 135   4                                  LCD_ShowString(1, 16, " ");
 136   4                      }
 137   3                  } else {
 138   3                      // 如果超出范围
 139   3                      LCD_ShowString(1, 1, "Out of Range");
 140   3                      // 清除第二行显示
 141   3                      LCD_ShowString(2, 1, "                "); // 用空格清除第二行
 142   3                  }
 143   2                              Delay(10);
 144   2                  break;
 145   2                      case 0x47:
 146   2                              LCD_ShowString(1,1,"Temperature:");
 147   2                              if(T<0)                         //如果温度小于0
 148   2                              {
 149   3                                      LCD_ShowChar(2,1,'-');  //显示负号
 150   3                                      T=-T;                   //将温度变为正数
 151   3                              }
 152   2                              else                            //如果温度大于等于0
 153   2                              {
 154   3                                      LCD_ShowChar(2,1,'+');  //显示正号
 155   3                              }
 156   2                              LCD_ShowNum(2,2,T,3);           //显示温度整数部分
 157   2                              LCD_ShowChar(2,5,'.');          //显示小数点
 158   2                              LCD_ShowNum(2,6,(unsigned long)(T*10000)%10000,4);//显示温度小数部分
 159   2                              break;
 160   2              default:
 161   2                  // 显示无效
 162   2                              LCD_ShowString(1,1,"key_number:");
 163   2                  LCD_ShowHexNum(2,5,menu_option,2);
 164   2                  break;
 165   2          }
 166   1      }
 167                  
 168          // 蜂鸣器按照1000Hz的频率响ms时间
 169          void Buzzer_Time(unsigned int ms)
 170          {
 171   1              unsigned int i;
 172   1              for(i=0;i<ms*2;i++)//控制时间：ms给100，蜂鸣器响100ms
 173   1              {
 174   2                      Buzzer = !Buzzer;//蜂鸣器引脚电平翻转发声
 175   2                      Delay_ms(1);//控制频率：每隔500us翻转一次
 176   2                      //高电平500us，低电平500us，T = 1000us，f = 1/10^-3(s) = 1000HZ
 177   2              }
 178   1      } 
C51 COMPILER V9.00   MAIN                                                                  09/21/2024 08:08:56 PAGE 4   

 179          
 180          
 181          
 182          void AT_Init(void)
 183          {
 184   1          printf("AT+CIPSNTPCFG=1,8,\"cn.ntp.org.cn\",\"ntp.sjtu.edu.cn\"");
 185   1              printf("\r\n");
 186   1              Delay(500);
 187   1          printf("AT+MQTTUSERCFG=0,1,\"NULL\",\"0c4qP0fwXkAUsGu2Mfhd&k1ryxzSF8vb\",\"80c67c1aadd0037752bae746b77
             -2036605b600c19c9025f12746757286b9e99b\",0,0,\"\"");
 188   1              printf("\r\n");
 189   1              Delay(500);
 190   1          printf("AT+MQTTCLIENTID=0,\"k1ryxzSF8vb.0c4qP0fwXkAUsGu2Mfhd|securemode=2\\,signmethod=hmacsha256\\,ti
             -mestamp=1726867041527|\"");
 191   1              printf("\r\n");
 192   1              Delay(500);
 193   1          printf("AT+MQTTCONN=0,\"iot-06z00acui5vtoxn.mqtt.iothub.aliyuncs.com\",1883,1");
 194   1              printf("\r\n");
 195   1              Delay(500);
 196   1      }               
 197          char putchar(char dat)
 198          {
 199   1              UART_SendByte(dat);           
 200   1              return dat;                    
 201   1      }
 202          void USART( ) interrupt  4
 203          {    
 204   1          static unsigned char i=0;
 205   1              if(RI==1)
 206   1              {       RI=0;
 207   2                      if(i>=16)   //收到字符串超过数组长度
 208   2                      { 
 209   3                              i=0;
 210   3                              UART_SendString("Data overflow !\r\n");
 211   3                              memset(Data,0x00,sizeof(Data)); //数组清零
 212   3                      }
 213   2              else
 214   2              {
 215   3                              Data[i++]=SBUF;
 216   3                              if( (Data[i-1]=='\n')  && (Data[i-2]=='\r') )  //判断结尾字符为回车换行符
 217   3                              {
 218   4                                      UART_SendString(Data) ;   //将收到的内容发送出去
 219   4                      memset(Data,0x00,sizeof(Data));//数组清零
 220   4                      i=0;                 
 221   4                              }
 222   3              }
 223   2              }   
 224   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1020    ----
   CONSTANT SIZE    =    610    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     29      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
